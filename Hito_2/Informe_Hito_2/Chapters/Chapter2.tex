% !TeX spellcheck = es_ES

\subsection{Temporal\_schemes}

\begin{lstlisting}[language=Python, caption=Código de la función Temporal\_schemes, label=Hito_2_Temporal_schemes_code]
from scipy import optimize

def Euler(U0, t0, tf, f):
    return U0 + (tf - t0) * f(t0, U0)

def Crank_Nicolson(U0, t0, tf, f):
    def Residual(x):
        return x - U0 - (tf - t0)/2 * (f(t0, U0) + f(tf, x))
    return optimize.newton(func = Residual, x0 = U0)

def RK4(U0, t0, tf, f):
    dt = tf - t0
    k1 = f(t0, U0)
    k2 = f(t0 + dt/2, U0 + k1*dt/2)
    k3 = f(t0 + dt/2, U0 + k2*dt/2)
    k4 = f(t0 + dt, U0 + k3*dt)
    return U0 + dt/6 * (k1 + 2*k2 + 2*k3 + k4)

def Inverse_Euler(U0, t0, tf, f):
    def Residual(x):
        return x - U0 - (t0 - tf) * f(tf, x)
    return optimize.newton(func = Residual, x0 = U0)

\end{lstlisting}

\subsection{Cauchy\_problem}

\begin{lstlisting}[language=Python, caption=Código de la función Cauchy\_problem, label=Hito_2_Cauchy_problem_code]
from numpy import array, zeros

def Cauchy(t, temporal_scheme, f, U0):
    U = array (zeros((len(U0),len(t))))
    U[:,0] = U0
    for ii in range(0, len(t) - 1):
        U[:,ii+1] = temporal_scheme(U[:,ii], t[ii], t[ii+1], f)
    return U

\end{lstlisting}

\subsection{Función principal (Hito\_2)}

\begin{lstlisting}[language=Python, caption=Código principal del Hito 2, label=Hito_2_main_code]
from numpy import arange, array
import matplotlib.pyplot as plt
from ODEs.Cauchy_problem import Cauchy
from ODEs.Temporal_schemes import Euler, Inverse_Euler, RK4, Crank_Nicolson

# Function to be integrated
def F_Kepler(t, U):
    
    x, y, vx, vy = U[0], U[1], U[2], U[3]
    mr = (x**2 + y**2)**1.5
    return array([vx, vy, -x/mr, -y/mr])

# Integration parameters definition
dt = 0.001
N = 10000
t0 = 0
t = arange(t0, N * dt, dt)
U0 = [1, 0, 0, 1]

# Cauchy problem solver
U = Cauchy(t, Crank_Nicolson, F_Kepler, U0)

# Plot results
plt.axis('equal')
plt.plot(U[0,:],U[1,:])
plt.show()

\end{lstlisting}











